/**
 * update‑schema.mjs
 *
 * This script auto‐generates src/databases/drizzle/schema.ts
 * by importing and spreading every *.model.ts from src/models/drizzle.
 */
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const modelsDir = path.resolve(__dirname, 'src', 'models', 'drizzle');
const schemaFile = path.resolve(__dirname, 'src', 'database', 'schema.ts');

console.log('Models directory:', modelsDir);
console.log('Schema file path:', schemaFile);

async function getModelFiles() {
	const files = await fs.readdir(modelsDir);
	return files.filter(f => f.endsWith('.model.ts'));
}

function getPascalSchemaName(modelFile) {
	const base = modelFile.replace(/\.model\.ts$/, '');
	return base.charAt(0).toUpperCase() + base.slice(1) + 'Schema';
}

async function updateSchema() {
	try {
		// Ensure both paths exist
		await fs.access(modelsDir);
		await fs.access(schemaFile);

		const modelFiles = await getModelFiles();
		if (modelFiles.length === 0) {
			console.log('No model files found. Exiting.');
			return;
		}

		const existing = await fs.readFile(schemaFile, 'utf8');

		// Determine which need adding (but we're regenerating fully anyway)
		const importLines = modelFiles
			.map(f => {
				const name = getPascalSchemaName(f);
				const importPath = `../models/drizzle/${f.replace(/\.ts$/, '')}`;
				return `import * as ${name} from "${importPath}";`;
			})
			.join('\n');

		const spreadLines = modelFiles.map(f => `\t...${getPascalSchemaName(f)}`).join(',\n');

		const generated =
			`// AUTO‑GENERATED by update‑schema.mjs. Do not edit by hand.\n\n` +
			importLines +
			'\n\n' +
			`const schema = {\n${spreadLines}\n};\n\nexport default schema;\n`;

		await fs.writeFile(schemaFile, generated, 'utf8');
		console.log('✅ schema.ts successfully updated with all models.');
	} catch (err) {
		console.error('❌ Failed to update schema:', err);
	}
}

updateSchema();
